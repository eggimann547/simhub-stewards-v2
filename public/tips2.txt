// === 3. LOAD tips2.txt (SAFE + ROBUST) ===
let proTip = '';
try {
  const baseUrl = process.env.VERCEL_URL ? `https://${process.env.VERCEL_URL}` : 'http://localhost:3000';
  const tipsRes = await fetch(`${baseUrl}/tips2.txt`, { 
    signal: controller.signal,
    headers: { 'Cache-Control': 'no-cache' } // Prevent stale
  });

  if (tipsRes.ok) {
    const text = await tipsRes.text();
    const lines = text.split('\n');

    const tips = [];
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed || !trimmed.includes('|')) continue;

      const parts = trimmed.split('|').map(p => p.trim());
      if (parts.length < 2) continue; // Need at least tip + category

      const tip = parts[0];
      const category = parts[1].toLowerCase();
      const source = parts.slice(2).join(' | ').trim(); // Rejoin extra |

      if (tip && category) {
        tips.push({ tip, category, source: source || '(Stewards AI)' });
      }
    }

    if (tips.length > 0) {
      const map = {
        divebomb: ['braking', 'overtaking'],
        'vortex exit': ['overtaking'],
        'weave block': ['defense'],
        'unsafe rejoin': ['rejoin', 'general'],
        'track limits': ['general'],
        netcode: ['netcode'],
        'used as barrier': ['defense'],
        'pit maneuver': ['general'],
        'general contact': ['general', 'defense', 'vision']
      };
      const targets = map[incidentType] || ['general'];
      const matched = tips.filter(t => targets.includes(t.category));
      const pool = matched.length > 0 ? matched : tips;
      const selected = pool[Math.floor(Math.random() * pool.length)];
      proTip = selected.source ? `${selected.tip} ${selected.source}` : selected.tip;
    }
  }
} catch (e) {
  console.log('tips2.txt failed (non-critical):', e.message);
}
